#!/usr/bin/perl
use strict;
use warnings;
my $i = -1;
my $j = 0;

my %hash = ("+" => 1, "-" => 1, "*" => 2, "/" => 2, "^" => 3); # Ключи и значения в хеше принято разделять =>
my $rx_oper = join '', map {'\\'.$_} keys %hash; # Понадобится для регулярок
my $elem;
$_ = <STDIN>;
chomp($_);

#my @arbeg = split(//,$_);

s/\s+//g;
# Пробелы проще удалить до split-a  (s/\s+//g;)
=rem
while($i != -2){#выкидываем из массива пробельные элементы
   $i=-1;
    $j=0;
  while($i == -1 and $j<=$#arbeg){
   if($arbeg[$j] eq ' '){$i = $j}; 
    $j++
  };    
  if($i != -1){splice(@arbeg,$i,1)}else{$i=-2}
};
=cut

s/(^|\()-/${1}0-/g;
# Такое преобразование тоже делается 1 регулярным выражением (s/\(-/(0-/g;)
=rem
$i=0;  
my $pred=$arbeg[0];
for($i=1;$i<=$#arbeg;$i++){#переобозначаем '(-' на '(0-'
   if(($arbeg[$i] eq '-') and ($pred eq '(')){
       splice(@arbeg,$i,1,0,'-')
    };    
   $pred=$arbeg[$i];
};
=cut

s/([$rx_oper])-/$1_/g;
# Опять таки обходимся 1 регулярным выражением (s/([+(-\/^*])-/$1_/g;)
=rem
$i=0;
my $pred=$arbeg[0];
for($i=1;$i<=$#arbeg;$i++){#переобозначаем унарный минус на "_"
   if(($arbeg[$i] eq '-') and (($pred eq '+') or ($pred eq '(')or ($pred eq '-') or ($pred eq '/')or ($pred eq '^') or ($pred eq '*'))){
       splice(@arbeg,$i,1,'_');
    };    
   $pred=$arbeg[$i];
};
=cut    

my @arbeg = /([^_\d]|[_\d]+)/g;
# Разбить по числам проще очередной регуляркой, вместо посимвольного сплита с дальнейшим объединением
=rem
my $pred=$arbeg[0];
$i=1;
while($i<=$#arbeg){#цифры собираем в число
    if((not exists $hash{$arbeg[$i]}) and (not exists $hash{$pred}) and ($pred ne '_') and ($pred ne '(') and ($arbeg[$i] ne ')')){
        $arbeg[$i-1]=$arbeg[$i-1]*10+$arbeg[$i];
        splice(@arbeg,$i,1);
        $i=$i-1;
    }
    $pred=$arbeg[$i];
    $i=$i+1;
}
=cut

#Модифицируем регулярку, которая добавляет 0 внутри скобок перед унарным минусом (s/(^|\()-/${1}0-/g;)
#if($arbeg[0] eq '-'){unshift(@arbeg,0)};

s/_/-/ for @arbeg;
#В массиве мы получаем опереции и числа включая те, которые содержат _ (унарный минус). Заменяем его на обычный минус 
=rem
$i=2;
my $pred0=$arbeg[0];
my $pred1=$arbeg[1];
while($i<=$#arbeg){# "унарный минус" + "число" преобразуем в "число * (-1)"
   if((not exists $hash{$arbeg[$i]}) and ($arbeg[$i] ne '(')  and ($pred1 eq '_') and (exists $hash{$pred0}) ){
       $arbeg[$i-1]=$arbeg[$i]*(-1);
       splice(@arbeg,$i,1);
       $i=$i-1;
    }
   $pred0=$arbeg[$i-1];
    $pred1=$arbeg[$i];
    $i=$i+1;
}
=cut
print "\n", 'Enitial expression: ';

print join ' ', @arbeg;
#Перл любит краткость 
=rem
foreach  $elem (@arbeg) {  
    print $elem,' ';  
};
=cut

my @arend;
my @arsign;
my $k;
while ($#arbeg>=0) {#создание польской обратной записи в @arend
    $k = shift(@arbeg);
    if (not exists $hash{$k}) {
        if ($k eq '(') {
            push(@arsign,$k)
        }
	elsif ($k eq ')') {
            $j = pop(@arsign); 
            while ($j ne '(') {
                push(@arend,$j);
                $j = pop(@arsign);
            };
        }
        else {
            push(@arend,$k)
        }
    }
    else {
        if ($#arsign >= 0) {
            $j = pop(@arsign);
            if ($j ne '(') {
                if ($hash{$k} > $hash{$j}) {
		    push(@arsign,$j,$k);
                }
	        else {
                    my $bol = 0;
                    while ($hash{$k} <= $hash{$j} and $bol == 0) {
                        push(@arend,$j);
                        if ($#arsign >=0) {
                            $j = pop(@arsign)
                        }
		        else {
                            $bol=1
	                }
                    }
                    if ($bol==0) {
	                push(@arsign,$j,$k)
	            }
                    else {
		        push(@arsign,$k)
	            }
                }
            }
            else {
	        push(@arsign,$j,$k)
            }
        }
        else {
            push(@arsign,$k)
        }
    }
};

push @arend, reverse @arsign;
# И снова перл любит краткость
=rem
while ($#arsign>=0) {
    $j = pop(@arsign);
    push(@arend,$j);
}
=cut

print "\n",'Reverse polish notation: ' ;

print join ' ', @arend;
=rem
foreach $elem (@arend) {  
    print $elem,' ';  
};
=cut

my @stek;
my $st1;
my $st2;
=rem
while ($#arend>=0) {#считаем выражение
    $k = shift(@arend);
=cut
while (defined($k = shift(@arend))) {
    if (not exists $hash{$k}){
        push(@stek,$k);
    }
    else {
        $st2=pop(@stek);
        $st1=pop(@stek);
# Разве тут может быть унарный минус в виде "_"?
=rem
	if($st1 eq '_'){
            $st2=$st2*(-1);
            $st1=pop(@stek);
        }
=cut
	if ($k eq '+') {push(@stek,$st1+$st2)};
        if ($k eq '-') {push(@stek,$st1-$st2)};
        if ($k eq '*') {push(@stek,$st1*$st2)};
        if ($k eq '^') {push(@stek,$st1**$st2)};
        if ($k eq '/') {push(@stek,$st1/$st2)}
    }
}    
 
print "\n",'Result: ';
print @stek;

